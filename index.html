<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Happy Birthday ‚Äî Tr√°i Tim 3D</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; background:#000; overflow:hidden; -webkit-tap-highlight-color: transparent; }
    canvas { display:block; }

    /* L·ªùi nh·∫Øn ch√≠nh */
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 88%;
      max-width: 720px;
      text-align: center;
      pointer-events: none;
      font-family: "Segoe UI", Roboto, Arial, sans-serif;
      color: #ffffff;
      line-height:1.6;
      font-size: 18px;
      text-shadow: 0 0 12px rgba(255,100,150,0.9);
    }

    /* Container ch·ªØ ch·∫°y v√≤ng */
    #orbit {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 420px;
      height: 420px;
      margin-left: -210px;
      margin-top: -210px;
      pointer-events: none;
      transform-origin: 50% 50%;
      animation: orbit-rotate 12s linear infinite;
      mix-blend-mode: screen;
    }
    @keyframes orbit-rotate {
      from { transform: translate(-50%,-50%) rotate(0deg); }
      to   { transform: translate(-50%,-50%) rotate(360deg); }
    }

    /* t·ª´ng k√Ω t·ª± tr√™n v√≤ng */
    .orbit-char {
      position: absolute;
      left: 50%;
      top: 50%;
      transform-origin: 0 -180px; /* b√°n k√≠nh ~180 */
      color: #ffd2ea;
      font-size: 18px;
      text-shadow: 0 0 8px rgba(255,100,180,0.9);
      white-space: pre;
      pointer-events: none;
    }

    /* n√∫t b·∫≠t/t·∫Øt nh·∫°c */
    #music-btn {
      position: absolute;
      right: 18px;
      bottom: 18px;
      z-index: 30;
      background: rgba(255,255,255,0.06);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.12);
      padding: 8px 12px;
      border-radius: 10px;
      backdrop-filter: blur(4px);
      cursor: pointer;
      font-size: 15px;
    }
    #music-btn:active { transform: translateY(1px); }

    /* mobile tweaks */
    @media (max-width:420px){
      #orbit { width:320px; height:320px; margin-left:-160px; margin-top:-160px; }
      .orbit-char { font-size:14px; transform-origin: 0 -140px; }
    }
  </style>
</head>
<body>
  <!-- Three.js canvas will be renderer into this canvas -->
  <canvas id="bg"></canvas>

  <!-- Orbiting text container (characters will be positioned by JS) -->
  <div id="orbit" aria-hidden="true"></div>

  <!-- Center message -->
  <div id="message" aria-hidden="true">
    <p style="margin:0;font-weight:700;font-size:20px">Tu·∫•n ‚ù§Ô∏è Nga</p>
    <p style="margin:6px 0 12px 0;">B√© iuuu c·ªßa anh th√™m tu·ªïi m·ªõi r·ªìi, b·ªõt b∆∞·ªõng 1 x√≠u nha üòÜ</p>
    <p style="margin:0;">Ch√∫c em lu√¥n xinh ƒë·∫πp, vui v·∫ª v√† h·∫°nh ph√∫c üíï</p>
    <p style="margin:8px 0 0 0;">C·∫£m ∆°n em ƒë√£ ƒë·∫øn v√† l√†m th·∫ø gi·ªõi c·ªßa anh r·ª±c r·ª° h∆°n ‚ú®</p>
    <p style="margin:8px 0 0 0;font-weight:600;">Sau n√†y, em v·∫´n lu√¥n l√† m·ªôt ph·∫ßn ƒë·∫∑c bi·ªát trong tim anh üíìüíó</p>
  </div>

  <!-- Music control -->
  <audio id="bg-music" loop preload="auto">
    <source src="https://cdn.pixabay.com/download/audio/2023/03/14/audio_3b5b7fba7c.mp3?filename=romantic-piano-melody-140990.mp3" type="audio/mpeg">
  </audio>
  <button id="music-btn">üéµ B·∫≠t nh·∫°c</button>

  <!-- Three.js lib -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
  /* ========= Setup renderer, scene, camera ========= */
  const canvas = document.getElementById('bg');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(window.innerWidth, window.innerHeight);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.z = 12;

  // lights
  const keyLight = new THREE.PointLight(0xffe6f2, 1.2);
  keyLight.position.set(5,6,6);
  scene.add(keyLight);
  const fill = new THREE.AmbientLight(0x404040, 0.7);
  scene.add(fill);

  /* ========= Create a heart mesh (3D solid) ========= */
  function makeHeartMesh() {
    const shape = new THREE.Shape();
    // smoother heart shape (centered)
    shape.moveTo(0, 1.2);
    shape.bezierCurveTo(0, 1.2, -1.2, 2.2, -2.4, 1.0);
    shape.bezierCurveTo(-3.6, -0.2, -1.5, -2.4, 0, -1.0);
    shape.bezierCurveTo(1.5, -2.4, 3.6, -0.2, 2.4, 1.0);
    shape.bezierCurveTo(1.2, 2.2, 0, 1.2, 0, 1.2);

    const geom = new THREE.ExtrudeGeometry(shape, {
      depth: 0.8, bevelEnabled: true, bevelSegments: 4, steps: 2, bevelSize: 0.3, bevelThickness: 0.3
    });
    geom.rotateX(Math.PI); // align nicely
    const mat = new THREE.MeshPhongMaterial({
      color: 0xff2d79,
      shininess: 180,
      specular: 0xffffff
    });
    const mesh = new THREE.Mesh(geom, mat);
    return { mesh, geom, mat };
  }

  const { mesh: heartMesh, geom: heartGeom, mat: heartMat } = makeHeartMesh();
  scene.add(heartMesh);

  /* ========= Particles (small spheres) ========= */
  const particleCount = 700; // tune for performance
  const particles = []; // array of objects {mesh, homePosition, velocity}
  const particleGeom = new THREE.SphereGeometry(0.035, 8, 8);
  const particleMat = new THREE.MeshBasicMaterial({ color: 0xff77a6 });

  // prepare a list of target positions (points on heart surface)
  const heartPoints = [];

  // sample heart geometry vertices / surface points to use as targets
  // if extrude geometry vertices are too clustered, generate points via param formula too
  // We'll add both: vertices from geometry and parametric points
  heartGeom.computeBoundingBox();
  // add parametric heart points (2D cardioid-like) for denser coverage
  function paramHeart(t, rFactor=1){
    // classic heart curve (2D), scale down
    const x = 16 * Math.pow(Math.sin(t),3);
    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
    return new THREE.Vector3(x*0.06*rFactor, -y*0.06*rFactor, (Math.random()-0.5)*0.3);
  }
  for(let i=0;i<1200;i++){
    const t = Math.random()*Math.PI*2;
    heartPoints.push(paramHeart(t, 0.9 + Math.random()*0.2));
  }

  // create particle meshes, initially hidden outside
  for(let i=0;i<particleCount;i++){
    const m = new THREE.Mesh(particleGeom, particleMat);
    // start positions scattered
    m.position.set((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10);
    scene.add(m);
    particles.push({
      mesh: m,
      home: heartPoints[i % heartPoints.length].clone(), // target heart position
      vel: new THREE.Vector3(0,0,0),
      phaseOffset: Math.random()*0.5
    });
  }

  /* ========= Orbit text (DOM) ========= */
  const orbitEl = document.getElementById('orbit');
  const orbitText = " Tu·∫•n ‚ù§Ô∏è Nga  ‚Ä¢  B√© iuuu c·ªßa anh  ‚Ä¢  Sau n√†y, em v·∫´n lu√¥n l√† m·ªôt ph·∫ßn ƒë·∫∑c bi·ªát trong tim anh üíìüíó  ‚Ä¢  Y√™u em nhi·ªÅu üòò ";
  // Create spans per character and position around circle
  const chars = orbitText.split('');
  const ringRadius = 180; // px
  const centerX = 210, centerY = 210; // based on orbit container default
  orbitEl.style.width = (ringRadius*2+40) + 'px';
  orbitEl.style.height = (ringRadius*2+40) + 'px';
  orbitEl.style.marginLeft = -(ringRadius+20) + 'px';
  orbitEl.style.marginTop = -(ringRadius+20) + 'px';

  for(let i=0;i<chars.length;i++){
    const span = document.createElement('span');
    span.className = 'orbit-char';
    span.textContent = chars[i];
    // angle around circle
    const angle = (i / chars.length) * Math.PI*2;
    const deg = angle * 180 / Math.PI;
    span.style.transform = `rotate(${deg}deg) translateX(${ringRadius}px) rotate(${deg*-1}deg)`;
    orbitEl.appendChild(span);
  }

  /* ========= Animation loop: explosion/regroup cycle ========= */
  const cycle = 5.0; // seconds per full cycle
  const clock = new THREE.Clock();

  // states:
  // phase 0: grouped (heart visible, particles gather) (0 - gatherTime)
  // phase 1: explode (particles fly outward) (gatherTime - explodeEnd)
  // phase 2: regroup (particles return to home positions) (explodeEnd - cycle)
  const gatherTime = 1.2;   // seconds heart stays & "beat"
  const explodeTime = 1.2;  // explosion duration
  const regroupTime = cycle - gatherTime - explodeTime; // rest -> regroup

  // helper easing
  function easeInOutQuad(t){
    return t<0.5 ? 2*t*t : -1 + (4-2*t)*t;
  }

  // initialize particle homes relative to heart mesh position
  function updateHomes() {
    // heart mesh world matrix
    heartMesh.updateMatrixWorld(true);
    // if hearts points generated relative to heart center, map them to world
    for(let i=0;i<particles.length;i++){
      const hv = particles[i].home.clone();
      // Because heart mesh rotated, we need to align homes to heart's world rotation/position
      const worldPos = hv.applyMatrix4(heartMesh.matrixWorld);
      particles[i].homeWorld = worldPos;
    }
  }
  // initial map
  updateHomes();

  // explosion initial velocities computed when explosion starts
  let explosionSeeds = [];
  function triggerExplosion() {
    explosionSeeds = [];
    for(let i=0;i<particles.length;i++){
      // direction from heart center to current home in world
      const home = particles[i].homeWorld.clone();
      const dir = home.clone().normalize();
      // random outward velocity
      const speed = 1.6 + Math.random()*1.2;
      const v = dir.multiplyScalar(speed);
      // add random tangent component
      v.x += (Math.random()-0.5)*1.2;
      v.y += (Math.random()-0.5)*1.2;
      v.z += (Math.random()-0.5)*1.2;
      explosionSeeds.push(v);
      // set current position at home for starting explosion
      particles[i].mesh.position.copy(home);
    }
  }

  // main animation
  function render(){
    requestAnimationFrame(render);
    const elapsed = clock.getElapsedTime();
    const phaseTime = elapsed % cycle;

    if(phaseTime < gatherTime){
      // GATHER phase (heart visible, small beat)
      const localT = phaseTime / gatherTime;
      // heart beats subtly
      const beat = 1 + 0.08 * Math.sin(localT * Math.PI * 2 * 2);
      heartMesh.visible = true;
      heartMesh.scale.set(beat,beat,beat);
      // hide particles near center
      for(let p of particles) p.mesh.visible = false;
    } else if (phaseTime < gatherTime + explodeTime){
      // EXPLODE phase
      const localT = (phaseTime - gatherTime) / explodeTime; // 0..1
      // on explosion start (localT just passed 0), trigger initial seeds once
      if(localT < 0.02 && explosionSeeds.length === 0){
        triggerExplosion();
      }
      heartMesh.visible = false;
      // move particles outward along seeds with slight easing
      for(let i=0;i<particles.length;i++){
        const seed = explosionSeeds[i];
        const p = particles[i];
        p.mesh.visible = true;
        // exponential-like expansion
        const dist = 1 + Math.pow(localT, 0.6) * (6 + (i%7)*0.01);
        const newPos = p.homeWorld.clone().add(seed.clone().multiplyScalar(localT * 1.4 * dist));
        p.mesh.position.lerp(newPos, 0.65); // smooth motion
      }
    } else {
      // REGROUP phase
      const localT = (phaseTime - gatherTime - explodeTime) / regroupTime; // 0..1
      // prepare homes updated (in case heart rotated) every regroup
      // compute easing 0..1
      const e = easeInOutQuad(localT);
      // particles move from their current exploded positions back to homeWorld
      for(let i=0;i<particles.length;i++){
        const p = particles[i];
        p.mesh.visible = true;
        // target = homeWorld (slightly jitter)
        const target = p.homeWorld;
        // set position = lerp(current, target, e)
        p.mesh.position.lerp(target, 0.05 + e*0.35); // smoothing towards home
      }
      // when regroup nearly complete, clean explosionSeeds to allow next explosion fresh
      if(localT > 0.95) explosionSeeds = [];
      // show heart once mostly regrouped
      if(localT > 0.8) {
        heartMesh.visible = true;
        heartMesh.scale.set(1,1,1);
      } else {
        heartMesh.visible = false;
      }
    }

    // continuous slow rotation for both heart and particles group feel
    heartMesh.rotation.y += 0.008;
    // slight camera bob
    camera.position.z = 11 + Math.sin(clock.getElapsedTime()*0.3)*0.25;

    renderer.render(scene, camera);
  }

  render();

  // Make homes track heart world transform when window resizes or periodically
  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    // adjust orbit radius for mobile
    const r = Math.min(window.innerWidth, window.innerHeight) * 0.35;
    orbitEl.style.width = (r*2 + 40) + 'px';
    orbitEl.style.height = (r*2 + 40) + 'px';
    orbitEl.style.marginLeft = -(r + 20) + 'px';
    orbitEl.style.marginTop = -(r + 20) + 'px';
  });

  // update particle homes to current heart world positions before first render
  // map param heart points into heartMesh local to world
  updateHomes();

  /* ========= Music control (autoplay friendly: user can press button) ========= */
  const music = document.getElementById('bg-music');
  const musicBtn = document.getElementById('music-btn');

  // toggle play/pause
  musicBtn.addEventListener('click', () => {
    if(music.paused){
      music.play().catch(()=>{ /* ignore autoplay block */ });
      musicBtn.textContent = '‚è∏Ô∏è T·∫Øt nh·∫°c';
    }else{
      music.pause();
      musicBtn.textContent = 'üéµ B·∫≠t nh·∫°c';
    }
  });

  // Try to auto-play once load (browsers may block; then user taps button)
  window.addEventListener('load', () => {
    music.play().then(() => {
      musicBtn.textContent = '‚è∏Ô∏è T·∫Øt nh·∫°c';
    }).catch(() => {
      musicBtn.textContent = 'üéµ B·∫≠t nh·∫°c';
    });
  });

  </script>
</body>
</html>
