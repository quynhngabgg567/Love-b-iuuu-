<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tuấn ❤️ Nga — Happy Birthday</title>
<style>
  :root{
    --pink:#ff6fcf;
    --violet:#b07bff;
    --glow: rgba(255,112,200,0.12);
  }
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:Inter, "Segoe UI", Roboto, Arial, sans-serif;}
  canvas{display:block; position:fixed; inset:0; z-index:1;}
  /* Trung tâm chữ (hiển thị trên tim) */
  #centerText{position:fixed;left:50%;top:44%;transform:translate(-50%,-50%);z-index:8;text-align:center;color:#ffb6e0;pointer-events:none;}
  #centerText h1{margin:0;font-size:22px;letter-spacing:0.2px;text-shadow:0 6px 20px rgba(191,80,180,0.25);color: #ff8fcf;}
  #centerText p{margin:8px 0;font-size:16px;color:#ffcFEF;opacity:0.95;text-shadow:0 3px 12px rgba(120,30,80,0.12);}
  /* Vòng chữ xoay như TikTok phía dưới (container xoay toàn bộ) */
  .circle-wrap{position:fixed;left:50%;bottom:8vh;transform:translateX(-50%);width:min(760px,92vw);height:220px;pointer-events:none;z-index:7;perspective:1000px;overflow:visible;}
  .rotater{position:absolute;inset:0;transform-style:preserve-3d;transform-origin:center center;animation:spinText 3.5s linear infinite;will-change:transform;}
  @keyframes spinText { from{ transform:rotate(0deg);} to{ transform:rotate(360deg);} }
  .rotater span{
    position:absolute; left:50%; top:50%;
    transform-origin: 0 -260px; /* radius (khoảng cách text -> tâm) */
    font-weight:600; color: #ff99cc; white-space:nowrap;
    text-shadow:0 2px 10px rgba(100,20,50,0.18); font-size:16px; letter-spacing:0.2px;
  }

  /* Nhạc button (nếu autoplay bị chặn) */
  #musicBtn{position:fixed;right:16px;bottom:16px;z-index:20;background:linear-gradient(135deg, rgba(255,110,180,0.14), rgba(140,50,210,0.06));border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:10px;color:#fff;backdrop-filter: blur(6px);cursor:pointer}
  #musicBtn svg{vertical-align:middle;margin-right:6px}

  /* Nhỏ gọn cho điện thoại */
  @media (max-width:520px){
    #centerText h1{font-size:18px}
    .rotater span{font-size:14px}
    .circle-wrap{height:160px}
  }
</style>
</head>
<body>

<canvas id="bg"></canvas>

<!-- Trung tâm nội dung (giữ nguyên nội dung lời chúc) -->
<div id="centerText" aria-hidden="true">
  <h1>Tuấn ❤️ Nga. Anh yêu em 💕😘</h1>
  <p>Bé iuuu của anh thêm tuổi mới rồi, bớt bướng 1 xíu nha 😆</p>
  <p>Gửi em 20/10 vui vẻ 😘</p>
  <p>Chúc người con gái anh yêu! Không chỉ hôm nay, mà tất cả 360 ngày còn lại đều vui vẻ, xinh đẹp em nhé 🫂💗</p>
  <p>Chúc em tất cả những điều tốt đẹp nhất💖</p>
  <p>Chúc em bé của anh sẽ thật mạnh mẽ trên con đường phía trước 💪🌸</p>
  <p>Sau này, em vẫn mãi là một phần đặc biệt trong tim anh ♥️💗</p>
  <p>Cảm ơn vì hai ta đã gặp nhau ở độ tuổi đẹp nhất 🫂💕</p>
  <p style="font-weight:700;color:#ffd1e8">♥️ Yêu em ♥️</p>
</div>

<!-- Vòng chữ xoay (nội dung tách thành nhiều đoạn để đặt vòng) -->
<div class="circle-wrap" aria-hidden="true">
  <div class="rotater" id="rotater"></div>
</div>

<!-- Audio: thay AUDIO_SRC_HERE bằng link mp3 (Zing hoặc URL công khai) -->
<audio id="bgMusic" loop crossorigin="anonymous">
  <source src="AUDIO_SRC_HERE" type="audio/mpeg">
  <!-- Nếu không có link, tệp sẽ không chơi; nút bật nhạc dùng để play -->
</audio>

<button id="musicBtn" title="Bật/Tắt nhạc" aria-label="Bật Tắt nhạc">
  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" style="filter: drop-shadow(0 2px 6px rgba(0,0,0,0.4));">
    <path d="M5 9v6h4l5 5V4L9 9H5z" fill="#ffd1e8"/>
  </svg>
  Bật/Tắt nhạc
</button>

<!-- Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
/* ========== helper: chữ vòng quanh ========== */
const rotater = document.getElementById('rotater');
// Nội dung xoay (mình ghép nhiều đoạn, để chữ hiện nhiều vòng)
const texts = [
  "Tuấn ❤️ Nga · Anh yêu em 💕😘",
  "Bé iuuu của anh thêm tuổi mới rồi, bớt bướng 1 xíu nha 😆",
  "Gửi em 20/10 vui vẻ 😘",
  "Chúc người con gái anh yêu! 360 ngày còn lại đều vui vẻ, xinh đẹp em nhé 🫂💗",
  "Chúc em tất cả những điều tốt đẹp nhất💖",
  "Chúc em bé của anh sẽ thật mạnh mẽ trên con đường phía trước 💪🌸",
  "Sau này, em vẫn mãi là một phần đặc biệt trong tim anh ♥️💗",
  "Cảm ơn vì hai ta đã gặp nhau ở độ tuổi đẹp nhất 🫂💕",
  "♥️ Yêu em ♥️"
];
// Tạo rất nhiều span để vòng chữ dày như TikTok
const RINGS = 3; // số lớp vòng chữ
for(let ring=0; ring<RINGS; ring++){
  texts.forEach((txt,i)=>{
    const s = document.createElement('span');
    s.textContent = txt;
    // góc đặt: đều, có offset theo vòng
    const angle = (i / texts.length) * 360 + ring * 20;
    s.style.transform = `rotate(${angle}deg) translateY(-${260 - ring*40}px) rotate(${-angle}deg)`;
    rotater.appendChild(s);
  });
}

/* ========== Three.js particle heart ========== */
const canvas = document.getElementById('bg');
const renderer = new THREE.WebGLRenderer({canvas, alpha:true, antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 40;

// lights
const amb = new THREE.AmbientLight(0x202020);
scene.add(amb);
const pLight = new THREE.PointLight(0xff99d9, 1.2, 200);
pLight.position.set(30,30,50);
scene.add(pLight);

// create particle material (sprite-like)
const sprite = new THREE.TextureLoader().load('https://i.imgur.com/9yG6i7Q.png'); // small soft dot
const particlesMat = new THREE.PointsMaterial({
  size: 0.6,
  map: sprite,
  color: 0xffb3d9,
  transparent: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

// heart param -> returns Vector3
function heartFormula(t){
  // param t in [0, 2PI]
  const x = 16 * Math.pow(Math.sin(t), 3);
  const y = 13 * Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
  // scale down
  return new THREE.Vector3(x*0.9, y*0.9 - 5, (Math.cos(2*t) * 1.2));
}

// buffer geometry
const PARTICLE_COUNT = 1600;
const positions = new Float32Array(PARTICLE_COUNT * 3);
const basePositions = new Float32Array(PARTICLE_COUNT * 3);
const velocities = new Float32Array(PARTICLE_COUNT * 3); // dynamic velocities for explosion

// initialize positions around heart shape with jitter
for(let i=0;i<PARTICLE_COUNT;i++){
  const t = Math.random() * Math.PI * 2;
  const p = heartFormula(t);
  // jitter radial
  const jitter = (Math.random()-0.5) * 0.6;
  p.x += jitter * (Math.random() * 0.5);
  p.y += jitter * (Math.random() * 0.5);
  p.z += (Math.random()-0.5)*0.6;
  basePositions[i*3+0] = p.x;
  basePositions[i*3+1] = p.y;
  basePositions[i*3+2] = p.z;
  positions[i*3+0] = p.x + (Math.random()-0.5)*6; // start slightly dispersed
  positions[i*3+1] = p.y + (Math.random()-0.5)*6;
  positions[i*3+2] = p.z + (Math.random()-0.5)*6;
  velocities[i*3+0] = velocities[i*3+1] = velocities[i*3+2] = 0;
}

const geometry = new THREE.BufferGeometry();
geometry.setAttribute('position', new THREE.BufferAttribute(positions,3));
geometry.setAttribute('basePos', new THREE.BufferAttribute(basePositions,3));

const points = new THREE.Points(geometry, particlesMat);
scene.add(points);

// helper states
let exploded = false;
const explosionInterval = 5000; // 5s
let lastExplosion = 0;
let clock = new THREE.Clock();
let pulse = 0;

// explosion routine: give velocities outward
function explodeNow(){
  exploded = true;
  lastExplosion = performance.now();
  for(let i=0;i<PARTICLE_COUNT;i++){
    // direction from center to base pos
    const bx = basePositions[i*3+0];
    const by = basePositions[i*3+1];
    const bz = basePositions[i*3+2];
    // random outward velocity
    const vx = (bx + (Math.random()-0.5)) * (2 + Math.random()*3);
    const vy = (by + (Math.random()-0.5)) * (2 + Math.random()*3);
    const vz = (bz + (Math.random()-0.5)) * (2 + Math.random()*3);
    velocities[i*3+0] = vx * (0.9 + Math.random()*0.4);
    velocities[i*3+1] = vy * (0.9 + Math.random()*0.4) + 6 * (Math.random()*0.4); // give upward boost
    velocities[i*3+2] = vz * (0.9 + Math.random()*0.4);
  }
}

// animate loop
function animate(){
  requestAnimationFrame(animate);
  const elapsed = clock.getElapsedTime();
  // subtle pulse scale
  pulse = 1 + 0.06 * Math.sin(elapsed * 3);
  points.scale.set(pulse, pulse, pulse);

  const posAttr = geometry.attributes.position;
  for(let i=0;i<PARTICLE_COUNT;i++){
    const ix = i*3;
    // if exploded: particle moves by velocity with damping; else ease back to basePos
    if(exploded){
      // update pos by vel * dt
      positions[ix+0] += velocities[ix+0] * 0.02;
      positions[ix+1] += velocities[ix+1] * 0.02;
      positions[ix+2] += velocities[ix+2] * 0.02;
      // apply drag
      velocities[ix+0] *= 0.96;
      velocities[ix+1] *= 0.96;
      velocities[ix+2] *= 0.96;
      // slowly reduce alpha by moving back after 0.9s
      if(performance.now() - lastExplosion > 1200){
        // attract back
        positions[ix+0] += (basePositions[ix+0] - positions[ix+0]) * 0.02;
        positions[ix+1] += (basePositions[ix+1] - positions[ix+1]) * 0.02;
        positions[ix+2] += (basePositions[ix+2] - positions[ix+2]) * 0.02;
      }
    } else {
      // gently settle into base
      positions[ix+0] += (basePositions[ix+0] - positions[ix+0]) * 0.06;
      positions[ix+1] += (basePositions[ix+1] - positions[ix+1]) * 0.06;
      positions[ix+2] += (basePositions[ix+2] - positions[ix+2]) * 0.06;
    }
    // tiny random twinkle
    positions[ix+0] += (Math.random()-0.5) * 0.002;
    positions[ix+1] += (Math.random()-0.5) * 0.002;
  }
  // end explosion state after some time
  if(exploded && performance.now() - lastExplosion > 2000){
    exploded = false;
  }
  posAttr.needsUpdate = true;

  // rotate whole particle cloud slowly for 3D feel
  points.rotation.y += 0.006;
  points.rotation.x = Math.sin(elapsed*0.2) * 0.06;

  renderer.render(scene, camera);

  // trigger periodic explosions
  if(performance.now() - lastExplosion > explosionInterval){
    explodeNow();
  }
}
animate();

/* ========== resize handling ========== */
window.addEventListener('resize', () => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});

/* ========== Music control ========== */
const music = document.getElementById('bgMusic');
const musicBtn = document.getElementById('musicBtn');

// try autoplay (may be blocked by browser)
function tryPlayMusic(){
  music.volume = 0.7;
  const p = music.play();
  if(p !== undefined){
    p.catch(()=>{ /* autoplay blocked */ });
  }
}

// add button toggling
let isPlaying = false;
musicBtn.addEventListener('click', ()=>{
  if(isPlaying){
    music.pause(); isPlaying = false; musicBtn.textContent = 'Bật/Tắt nhạc';
  } else {
    music.play().then(()=>{ isPlaying = true; musicBtn.textContent = 'Tắt nhạc'; }).catch(()=>{ isPlaying=false; });
  }
});

// auto attempt play on load
window.addEventListener('load', () => {
  tryPlayMusic();
  // detect if music actually playing after brief delay
  setTimeout(()=>{ if(!music.paused) { isPlaying=true; musicBtn.textContent='Tắt nhạc'; } }, 800);
});

/* ========== small depth glow overlay (CSS-like via canvas) ========== */
// create subtle pink-purple vignette by overlaying a transparent plane in three.js
const vignetteGeo = new THREE.PlaneGeometry(200,200);
const vignetteMat = new THREE.MeshBasicMaterial({
  map: null,
  transparent:true,
  opacity:0.25,
  depthWrite:false,
  blending:THREE.AdditiveBlending,
  color:0xff66cc
});
// we won't attach a texture now; leave subtle ambient color via fog-like ambient
scene.fog = new THREE.FogExp2(0x000000, 0.002);

</script>
</body>
</html>
