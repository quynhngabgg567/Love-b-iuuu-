<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Happy Birthday ❤️</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family: "Segoe UI", Roboto, Arial, sans-serif;}
  canvas{display:block}
  #ui {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%,-50%);
    pointer-events: none;
    z-index: 10;
    text-align:center;
    color:#fff;
    mix-blend-mode:screen;
  }
  #centerText{
    pointer-events: none;
    color: #ffb6e0;
    text-shadow: 0 6px 18px rgba(255,20,120,0.25);
    font-size:18px;
    line-height:1.4;
    max-width: 80vw;
    margin: 0 auto;
  }
  #music-btn {
    position: fixed;
    right: 18px;
    bottom: 18px;
    z-index: 20;
    pointer-events: auto;
    background: rgba(255,255,255,0.06);
    color:#fff;
    border: 1px solid rgba(255,255,255,0.18);
    padding: 8px 12px;
    border-radius: 10px;
    backdrop-filter: blur(6px);
    cursor:pointer;
  }
  #music-btn:hover { background: rgba(255,255,255,0.12); }
  /* small screen tweaks */
  @media (max-width:520px){
    #centerText { font-size:16px; }
  }
</style>
</head>
<body>
  <canvas id="bg"></canvas>

  <div id="ui">
    <div id="centerText">
      <p style="margin:0;font-weight:600;">Tuấn ❤️ Nga</p>
      <p style="margin:6px 0 8px 0;color:#ffdfef;">Anh yêu em 💕</p>
      <p style="margin:0;color:#ffd7e8;">
        Chúc bé iuuu sinh nhật thật vui vẻ 😘<br>
        Bé iuuu của anh thêm tuổi mới rồi, bớt bướng 1 xíu nha 😆<br>
        Chúc em luôn xinh đẹp, vui vẻ và hạnh phúc 💖<br>
        Cảm ơn em đã đến và làm thế giới của anh rực rỡ hơn ✨<br>
        Sau này dù như nào đi nữa, anh vẫn mong em luôn bình yên và hạnh phúc 💕<br>
        Chúc em bé của anh thật mạnh mẽ trên con đường phía trước 💪🌸<br>
        <strong>Sau này, em vẫn luôn là một phần đặc biệt trong tim anh 💓💗</strong>
      </p>
    </div>
  </div>

  <!-- nhạc (public sample) -->
  <audio id="bg-audio" loop crossorigin="anonymous">
    <source src="https://cdn.pixabay.com/download/audio/2023/03/14/audio_3b5b7fba7c.mp3?filename=romantic-piano-melody-14629.mp3" type="audio/mpeg">
  </audio>
  <button id="music-btn" aria-label="Play/Pause music">▶️ Bật nhạc</button>

  <!-- three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
  // ---------- CẤU HÌNH ----------
  const PARTICLE_COUNT = 2200;   // số hạt tim
  const TEXT_REPEAT = 40;        // số bản sao của lời nhắn vòng tròn
  const CYCLE_SECONDS = 5;       // vòng lặp (giây)
  const TEXT_MESSAGE = "Tuấn ❤️ Nga · Bé iuuu của anh · Yêu em nhiều 😘    ";
  // --------------------------------

  // set up renderer, scene, camera
  const canvas = document.querySelector('#bg');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
  renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 1000);
  camera.position.z = 18;

  renderer.setSize(innerWidth, innerHeight);
  renderer.setClearColor(0x000000, 1);

  // lights for slight 3D shading (particles use Points so lights don't matter much,
  // but 3D extrude would)
  scene.add(new THREE.AmbientLight(0x888888));

  // ---------- TẠO DỮ LIỆU TIM (heart formula) ----------
  function heartFormula(t){
    // clássico heart curve scaled down
    const x = 16 * Math.pow(Math.sin(t),3);
    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
    // add depth (z) from third harmonic for nice 3D shape
    const z = (Math.sin(3*t) * 2.5);
    return new THREE.Vector3(x*0.12, y*0.12, z*0.08);
  }

  // create heart positions (array of size PARTICLE_COUNT)
  const heartPositions = new Float32Array(PARTICLE_COUNT * 3);
  const explodedPositions = new Float32Array(PARTICLE_COUNT * 3);

  for(let i=0;i<PARTICLE_COUNT;i++){
    const t = Math.random() * Math.PI * 2;
    const v = heartFormula(t);
    // jitter a bit radially so shape is filled
    const jitter = (Math.random()*0.7 + 0.3);
    heartPositions[i*3+0] = v.x * jitter;
    heartPositions[i*3+1] = v.y * jitter;
    heartPositions[i*3+2] = v.z * jitter * (0.8 + Math.random()*1.2);

    // exploded positions: random in a sphere
    const rx = (Math.random()-0.5)*40;
    const ry = (Math.random()-0.5)*40;
    const rz = (Math.random()-0.5)*40;
    explodedPositions[i*3+0] = rx;
    explodedPositions[i*3+1] = ry;
    explodedPositions[i*3+2] = rz;
  }

  // buffer geometry for particles
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(PARTICLE_COUNT * 3);
  // init at heart
  positions.set(heartPositions);
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

  const material = new THREE.PointsMaterial({
    color: 0xff5aa4,
    size: 0.14,
    sizeAttenuation: true,
    transparent: true,
    opacity: 0.95,
    depthWrite:false,
    blending: THREE.AdditiveBlending,
  });

  const particles = new THREE.Points(geometry, material);
  scene.add(particles);

  // ---------- TẠO VÒNG CHỮ XOAY (sprites) ----------
  const textGroup = new THREE.Group();
  scene.add(textGroup);

  // helper to create sprite from text
  function createTextSprite(text, opts = {}){
    const font = opts.font || "28px Arial";
    const padding = opts.padding || 12;
    const color = opts.color || "#ffb6e0";
    const bg = opts.bg || "transparent";

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = font;
    // size canvas to text
    const w = Math.ceil(ctx.measureText(text).width) + padding*2;
    const h = Math.ceil(parseInt(font,10) * 1.4) + padding*2;
    canvas.width = w;
    canvas.height = h;

    // draw
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,w,h);
    ctx.font = font;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // glow shadow
    ctx.shadowColor = "rgba(255,60,150,0.55)";
    ctx.shadowBlur = 18;
    ctx.fillStyle = color;
    ctx.fillText(text, w/2, h/2);

    const tex = new THREE.CanvasTexture(canvas);
    tex.minFilter = THREE.LinearFilter;
    const mat = new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false });
    const sp = new THREE.Sprite(mat);
    // scale sprite down in world units
    const scale = Math.max(2.2, w/60);
    sp.scale.set(scale, scale * (h/w), 1);
    return sp;
  }

  // build repeated message sprites around a circle
  const radius = 9;
  for(let i=0;i<TEXT_REPEAT;i++){
    const angle = (i / TEXT_REPEAT) * Math.PI * 2;
    // repeat the message but shorten for sprite width
    const msg = TEXT_MESSAGE;
    const sp = createTextSprite(msg, { font: "22px Arial", color:"#ffd7f0" });
    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;
    const y = -4 + Math.sin(angle*3) * 0.5; // slight vertical variation
    sp.position.set(x, y, z);
    // face center by rotating toward camera direction each frame
    textGroup.add(sp);
  }

  // small central subtle glow (not necessary but nice)
  const centerGlowGeo = new THREE.SphereGeometry(0.6, 16, 16);
  const centerGlowMat = new THREE.MeshBasicMaterial({ color: 0xffc0dd, transparent:true, opacity:0.08 });
  const centerGlow = new THREE.Mesh(centerGlowGeo, centerGlowMat);
  centerGlow.position.set(0,0,0);
  scene.add(centerGlow);

  // ---------- ANIMATION (nổ và gom) ----------
  let clock = new THREE.Clock();
  function easeInOutQuad(t){ return t<0.5 ? 2*t*t : -1 + (4-2*t)*t; }

  function animate(){
    requestAnimationFrame(animate);
    const elapsed = clock.getElapsedTime();

    // compute cycle factor u in [0,1)
    const u = (elapsed % CYCLE_SECONDS) / CYCLE_SECONDS;
    // explosion factor: 0 -> heart, 0.5 -> exploded (max), 1-> heart
    let t;
    if(u <= 0.5) t = easeInOutQuad(u / 0.5); else t = easeInOutQuad((1 - u) / 0.5);
    // t in [0,1] controls mixing between heartPositions(0) and explodedPositions(1)
    // apply to positions
    const posAttr = geometry.attributes.position.array;
    for(let i=0;i<PARTICLE_COUNT;i++){
      const hi = i*3;
      // linear interpolate
      posAttr[hi+0] = heartPositions[hi+0] * (1 - t) + explodedPositions[hi+0] * t;
      posAttr[hi+1] = heartPositions[hi+1] * (1 - t) + explodedPositions[hi+1] * t;
      posAttr[hi+2] = heartPositions[hi+2] * (1 - t) + explodedPositions[hi+2] * t;
    }
    geometry.attributes.position.needsUpdate = true;

    // slight pulse when forming back to heart
    const pulse = 1 + 0.03 * Math.sin(elapsed * 5);
    particles.scale.set(pulse, pulse, pulse);

    // rotate the circular text group continuously to create "nối đuôi xoay vòng"
    const spinSpeed = (Math.PI * 2) / 20; // full rotation in 20s for gentle spin
    textGroup.rotation.y = elapsed * spinSpeed;

    // make each sprite always face camera (billboard)
    textGroup.children.forEach((sp) => {
      sp.quaternion.copy(camera.quaternion);
    });

    // render
    renderer.render(scene, camera);
  }
  animate();

  // responsive
  window.addEventListener('resize', () => {
    renderer.setSize(innerWidth, innerHeight);
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
  });

  // ---------- MUSIC BUTTON ----------
  const audio = document.getElementById('bg-audio');
  const musicBtn = document.getElementById('music-btn');
  let playing = false;
  musicBtn.addEventListener('click', () => {
    if(!playing){
      audio.play().catch(()=>{ /* may require user gesture on some browsers */ });
      musicBtn.textContent = "⏸️ Tắt nhạc";
      playing = true;
    } else {
      audio.pause();
      musicBtn.textContent = "▶️ Bật nhạc";
      playing = false;
    }
  });

  // autoplay attempt (browsers may block)
  setTimeout(()=> {
    // try once to play muted then unmute on user action if blocked
    audio.volume = 0.6;
    // don't autoplay forcibly to avoid being blocked; user can press button.
  }, 500);

  </script>
</body>
</html>
