<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Happy Birthday ‚ù§Ô∏è</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family: "Segoe UI", Roboto, Arial, sans-serif;}
    #container{position:fixed;inset:0;display:block;}
    canvas{display:block;}

    /* center messages */
    #message {
      position: absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      width:90%;
      max-width:720px;
      text-align:center;
      color:#ffb6d9;
      text-shadow:0 0 18px rgba(255,100,200,0.25);
      line-height:1.5;
      pointer-events:none;
    }
    #message h1{
      margin:0 0 10px;
      font-size:22px;
      color:#ff6fa8;
      letter-spacing:0.5px;
    }
    #message p{
      margin:6px 0;
      font-size:16px;
    }

    /* spinning circular text (below heart) */
    .circle-wrap {
      position: absolute;
      left:50%;
      bottom:6%;
      transform:translateX(-50%);
      width:600px;
      max-width:92vw;
      height:120px;
      pointer-events:none;
      perspective:1000px;
    }
    .rotater {
      position:absolute;
      inset:0;
      transform-style:preserve-3d;
      transform-origin:center center;
      animation:spinText 10s linear infinite;
    }
    .rotater span {
      position:absolute;
      left:50%;
      top:50%;
      transform-origin: -250px 0;
      font-size:18px;
      color:#ffb6d9;
      text-shadow:0 0 8px rgba(255,120,200,0.25);
      white-space:nowrap;
      opacity:0.95;
      filter:drop-shadow(0 2px 6px rgba(200,50,130,0.25));
    }

    @keyframes spinText {
      from { transform: rotate(0deg); }
      to   { transform: rotate(360deg); }
    }

    /* small music button if autoplay blocked */
    #musicBtn {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 9999;
      background: linear-gradient(135deg, rgba(255,120,200,0.14), rgba(200,80,150,0.16));
      border: 1px solid rgba(255,255,255,0.08);
      color:#fff;
      padding:10px 12px;
      border-radius:10px;
      backdrop-filter: blur(6px);
      cursor:pointer;
      display:flex;
      gap:8px;
      align-items:center;
      font-size:14px;
    }
    #musicBtn.hidden{display:none;}
    #musicBtn svg{width:18px;height:18px;fill:#ffbfdc;}
  </style>
</head>
<body>
  <div id="container">
    <canvas id="bg"></canvas>
    <div id="message">
      <h1>Tu·∫•n ‚ù§Ô∏è Nga</h1>
      <p>B√© iuuu c·ªßa anh th√™m tu·ªïi m·ªõi r·ªìi, b·ªõt b∆∞·ªõng 1 x√≠u nha üòÜ</p>
      <p>Ch√∫c em lu√¥n xinh ƒë·∫πp, vui v·∫ª v√† h·∫°nh ph√∫c üíñ</p>
      <p>Ch√∫c em b√© c·ªßa anh s·∫Ω th·∫≠t m·∫°nh m·∫Ω tr√™n con ƒë∆∞·ªùng ph√≠a tr∆∞·ªõc üí™üå∏</p>
      <p>Sau n√†y, em v·∫´n m√£i l√† m·ªôt ph·∫ßn ƒë·∫∑c bi·ªát trong tim anh ‚ô•Ô∏èüíó</p>
      <p>C·∫£m ∆°n v√¨ hai ta ƒë√£ g·∫∑p nhau ·ªü ƒë·ªô tu·ªïi ƒë·∫πp nh·∫•t ü´Çüíï</p>
    </div>

    <div class="circle-wrap" aria-hidden="true">
      <div class="rotater" id="rotater"></div>
    </div>
  </div>

  <!-- audio: ƒë·ªïi 'your-song.mp3' th√†nh file mp3 b·∫°n upload v√†o repo -->
  <audio id="bgAudio" loop preload="auto" src="your-song.mp3"></audio>

  <button id="musicBtn" class="hidden" title="B·∫≠t nh·∫°c">
    <svg viewBox="0 0 24 24"><path d="M3 10v4h4l5 5V5L7 10H3z"/></svg>
    B·∫≠t nh·∫°c
  </button>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
  // ====== Setup scene, camera, renderer ======
  const canvas = document.getElementById('bg');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;

  const scene = new THREE.Scene();
  // subtle ambient pink/purple fog glow
  scene.fog = new THREE.FogExp2(0x000000, 0.0025);

  const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 60);

  // lights
  const amb = new THREE.AmbientLight(0x222222);
  scene.add(amb);
  const point = new THREE.PointLight(0xff8fbf, 1.2, 150);
  point.position.set(20, 30, 40);
  scene.add(point);
  const point2 = new THREE.PointLight(0x8b3fff, 0.6, 150);
  point2.position.set(-20, -10, 40);
  scene.add(point2);

  // ====== Heart particle system ======
  const PARTICLE_COUNT = 1600;
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(PARTICLE_COUNT * 3);
  const basePositions = new Float32Array(PARTICLE_COUNT * 3); // target heart coords
  const velocities = new Float32Array(PARTICLE_COUNT * 3);

  // heart param function (2D) -> scale later
  function heartFormula(t, scale = 8){
    // parametric heart (polar-like) curve scaled
    const x = 16*Math.pow(Math.sin(t),3);
    const y = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
    return [ (x/2) * scale, (y/2) * scale ];
  }

  // distribute particles along heart outline with small random offset
  for(let i=0;i<PARTICLE_COUNT;i++){
    const t = (i / PARTICLE_COUNT) * Math.PI * 2;
    const p = heartFormula(t, 1.2);
    // random radius jitter
    const jitter = (Math.random()-0.5) * 1.2;
    const x = p[0] + jitter * (Math.random()-0.5);
    const y = p[1] + jitter * (Math.random()-0.5) * 0.6;
    const z = (Math.random()-0.5) * 2; // slight depth
    basePositions[i*3]   = x;
    basePositions[i*3+1] = y;
    basePositions[i*3+2] = z;
    // start positions (we'll initially place at base)
    positions[i*3] = x;
    positions[i*3+1] = y;
    positions[i*3+2] = z;
    velocities[i*3]=velocities[i*3+1]=velocities[i*3+2]=0;
  }

  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('basePos', new THREE.BufferAttribute(basePositions, 3));
  geometry.setAttribute('vel', new THREE.BufferAttribute(velocities, 3));

  // particle material
  const sprite = new THREE.TextureLoader().load('https://i.imgur.com/7kS0YpH.png'); // small soft dot
  const material = new THREE.PointsMaterial({
    size: 0.9 * (window.devicePixelRatio>1?1.6:1),
    map: sprite,
    transparent: true,
    opacity: 0.95,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    color: new THREE.Color(0xff6fbf)
  });

  const points = new THREE.Points(geometry, material);
  scene.add(points);

  // extra glow: a translucent mesh heart (to give 3D depth)
  const heartShape = new THREE.Shape();
  heartShape.moveTo(0,0);
  heartShape.bezierCurveTo(0,0,-2.5,-2.5,-2.5,-5);
  heartShape.bezierCurveTo(-2.5,-7.5,0,-7.5,0,-5);
  heartShape.bezierCurveTo(0,-7.5,2.5,-7.5,2.5,-5);
  heartShape.bezierCurveTo(2.5,-2.5,0,0,0,0);
  const extrudeGeo = new THREE.ExtrudeGeometry(heartShape,{depth:2,bevelEnabled:true,bevelSize:0.3,bevelThickness:0.2,steps:2});
  const heartMat = new THREE.MeshPhongMaterial({color:0xff2f7b,emissive:0x8a2fff,transparent:true,opacity:0.18});
  const heartMesh = new THREE.Mesh(extrudeGeo, heartMat);
  heartMesh.scale.set(2.8,2.8,2.8);
  heartMesh.rotation.y = Math.PI;
  heartMesh.position.z = -6;
  scene.add(heartMesh);

  // control explosion loop
  let clock = new THREE.Clock();
  let loopTime = 5.0; // seconds per cycle
  let exploded = false;
  let lastExplosion = -999;

  function explodeParticles(){
    // give outward velocities from center
    for(let i=0;i<PARTICLE_COUNT;i++){
      // direction vector from center to base pos
      const bx = basePositions[i*3];
      const by = basePositions[i*3+1];
      const bz = basePositions[i*3+2];
      // random outward vector
      const vx = (bx + (Math.random()-0.5)*2) * (1.5 + Math.random()*2.6);
      const vy = (by + (Math.random()-0.5)*2) * (1.5 + Math.random()*2.6);
      const vz = (bz*0.2 + (Math.random()-0.5)*2) * (1.5 + Math.random()*2.6);
      velocities[i*3] = vx;
      velocities[i*3+1] = vy + 5*(Math.random()-0.5);
      velocities[i*3+2] = vz;
    }
    exploded = true;
    lastExplosion = clock.getElapsedTime();
  }

  // initially slightly shimmering -> then start loop
  setTimeout(()=>{ explodeParticles(); }, 900);

  // animation loop
  function animate(){
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();

    // if time to trigger explosion again (every loopTime seconds)
    if(t - lastExplosion > loopTime){
      explodeParticles();
    }

    // update particle positions
    const pos = geometry.attributes.position.array;
    const base = geometry.attributes.basePos.array;
    const vel = geometry.attributes.vel.array;

    for(let i=0;i<PARTICLE_COUNT;i++){
      const idx = i*3;
      if(exploded){
        // apply velocity with damping
        vel[idx] *= 0.95;
        vel[idx+1] *= 0.92;
        vel[idx+2] *= 0.95;
        pos[idx] += vel[idx] * 0.02;
        pos[idx+1] += vel[idx+1] * 0.02;
        pos[idx+2] += vel[idx+2] * 0.02;

        // after ~2.2s start returning to base
        if(t - lastExplosion > 2.2){
          // move back toward base with easing
          const toBaseX = base[idx] - pos[idx];
          const toBaseY = base[idx+1] - pos[idx+1];
          const toBaseZ = base[idx+2] - pos[idx+2];
          pos[idx] += toBaseX * 0.06;
          pos[idx+1] += toBaseY * 0.06;
          pos[idx+2] += toBaseZ * 0.06;
        }
      } else {
        // gentle idle wobble
        pos[idx] = base[idx] + Math.sin(i + t*1.2) * 0.03;
        pos[idx+1] = base[idx+1] + Math.cos(i*0.5 + t*1.1) * 0.03;
      }

      // small pulsate on whole cloud
      pos[idx] *= 1 + Math.sin(t*1.8 + i*0.0006) * 0.001;
    }

    geometry.attributes.position.needsUpdate = true;

    // rotate whole group slowly for 3D feel
    points.rotation.y += 0.003;
    heartMesh.rotation.y += 0.0025;

    // subtle light color shift
    const c1 = new THREE.Color(0xff6fbf).lerp(new THREE.Color(0xbf7bff), (Math.sin(t*0.6)+1)/2 );
    material.color = c1;

    renderer.render(scene, camera);
  }
  animate();

  // handle resize
  window.addEventListener('resize', ()=> {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });

  // ====== rotating text creation (DOM) ======
  const rotater = document.getElementById('rotater');
  const texts = [
    "Tu·∫•n ‚ù§Ô∏è Nga",
    "B√© iuuu c·ªßa anh th√™m tu·ªïi m·ªõi r·ªìi, b·ªõt b∆∞·ªõng 1 x√≠u nha üòÜ",
    "Ch√∫c em lu√¥n xinh ƒë·∫πp, vui v·∫ª v√† h·∫°nh ph√∫c üíñ",
    "Ch√∫c em b√© c·ªßa anh s·∫Ω th·∫≠t m·∫°nh m·∫Ω tr√™n con ƒë∆∞·ªùng ph√≠a tr∆∞·ªõc üí™üå∏",
    "Sau n√†y, em v·∫´n m√£i l√† m·ªôt ph·∫ßn ƒë·∫∑c bi·ªát trong tim anh ‚ô•Ô∏èüíó",
    "C·∫£m ∆°n v√¨ hai ta ƒë√£ g·∫∑p nhau ·ªü ƒë·ªô tu·ªïi ƒë·∫πp nh·∫•t ü´Çüíï",
    "Y√™u em r·∫•t nhi·ªÅu"
  ];
  // populate many repeated spans to create 'n·ªëi ƒëu√¥i' continuous stream
  const repeat = 10; // increase to make longer chain
  const radius = Math.min(window.innerWidth, 600) * 0.38;
  for(let r=0;r<repeat;r++){
    for(let i=0;i<texts.length;i++){
      const el = document.createElement('span');
      el.textContent = texts[i] + "   ‚Ä¢   ";
      // angle for this element
      const idx = r*texts.length + i;
      const angle = (idx / (texts.length*repeat)) * Math.PI * 2;
      const deg = angle * 180/Math.PI;
      // place via transform: rotate + translate
      el.style.transform = `rotate(${deg}deg) translateX(${radius}px)`;
      rotater.appendChild(el);
    }
  }

  // ====== Audio autoplay handling ======
  const audio = document.getElementById('bgAudio');
  const musicBtn = document.getElementById('musicBtn');

  function tryPlayAudio(){
    audio.play().then(()=>{
      musicBtn.classList.add('hidden');
      // unmute if needed
    }).catch(()=> {
      // blocked: show button so user can tap
      musicBtn.classList.remove('hidden');
    });
  }
  // try autoplay on load
  window.addEventListener('load', ()=> {
    tryPlayAudio();
  });

  musicBtn.addEventListener('click', ()=>{
    audio.play();
    musicBtn.classList.add('hidden');
  });

  // helpful: start audio on first user interaction if blocked
  window.addEventListener('pointerdown', ()=> {
    if(audio.paused) audio.play().catch(()=>{});
    musicBtn.classList.add('hidden');
  }, {once:true});

  </script>
</body>
</html>
